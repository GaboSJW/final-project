<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Effect of withholding phonetics cues to English-Spanish Code-Switching</title>
    <meta charset="utf-8" />
    <meta name="author" content="Jiawei Shao" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/rutgers.css" rel="stylesheet" />
    <link href="libs/remark-css/rutgers-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Effect of withholding phonetics cues to English-Spanish Code-Switching
## methodoloy, result prediction and data simulation
### Jiawei Shao
### Rutgers University

---


---
# **Summary of the study**

--
Code-switching (CS) is the linguistic phenomenon when more than one language is used in one utterance. Various studies have reported switch cost in the recognition, comprehension and production process. Bilinguals are able to make use of hints in the matrix language of an CS utterance to help themselves recognize and process the upcoming CS phrase. In this study, we are trying to examine whether Spanish heritage speakers can make use of acoustic cues to mitigate the recognition of upcoming CS items in Enlish-Spanish CS context.  

--
  
We designed two experiments to test the listeners recognition speed of CS items, one reaction time experiment(listening and pressing button), another eye tracking experiment(listning and choosing corresponding item).  

--
  
In this presentation, as recommended, the stimulous analysis for experiment 1 is included, while experiment 2 is excluded for the complexity of eye tracking data is beyond what we've covered in this course.  
---
# **Methodology**

### Participants
- Spanish heritage speakers
- Advance learners of Spanish
- self reported frequent codeswitcher 

--

### Procedure of Experiment 1  
Participants will listen to CS stimuli, while looking at the image of a item(or a character) in the screen. When they hear the image mentioned in the audio stimuli, they should press the button as fast as they can.

---
# **Methodology**

--
### Data of participants

--
- Age
- Sex
- Year of learning Spanish
- Language dominance
- CS frequency in life
- Spanish proficiency  

--

All the the above mentioned variables are collapsed as one random variable: subject.

--
### Data collected in the Experiment

--
- Reaction time  

--
calculated from the onset of the target phrase  
4 types of sentences that contains different stimuli  
type 1: naturally produced monolingual English sentence(16/participant)  
type 2: naturally produced English-Spanish CS sentence(16/participant)  
type 3: CS(EN)+CS(ES) hybrid English-Spanish CS sentence (16/participant)
type 4: monolingual(EN)+CS(ES) hybrid English-Spanish CS sentence(16/participant)  

---
# **Prediction**

--
#### Prediction 1
Listeners will spend more time to recognize the item in bilingual context than in monolingual context.  

--
### Prediction 2
Listerns will not show much difference in RT when comparing RT2 and RT3, as the only variable changed is whether or not the sentences has gone throught the splice procedure.

--
### Prediction 3
Listeners will spend more time to recognize the item in the monolingual(EN)+CS(ES) hybrid English-Spanish CS sentence than naturally produced CS sentences.


---
# **Data Tidy**

### step 1
Each subject will provide 64 data points:16 RT for each type of sentence.  
We'll calculate the mean of each group of 16 RT of same sentence type.  

### step 2
We'll filter the data for each comparison that involved in each of the 3 predictions:  
type 1 vs type 2  
type 2 vs type 3  
type 2 vs type 4  

---
# **Run tests and make plots**

### step 1
Import all the untidy data in one figure that contains jitter plot and box plot and observe the pattern that the plots show.The X axis is the type of sentences and y axis is RT.

### step 2
Import the tidy data by comparison pairs. As the experiment has various participants, each participant could have distinct inherent reaction speed, we are using GLMM including subject as a random variable. Both random slope and random intercept are taken into account.

### step 3
Repeat step 2 with the other 2 pairs of data.

---
# **Current state of the project**

This project is part of a bigger research proposal for another course. As we don't have real data collected, data simulation is required for the test and analysis. 
Currently we have determined the range and SD of language history information of the participants, as well as the range of experiment result data that will fit our prediction. 
We are using package faux in R to generate simulated data.



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
